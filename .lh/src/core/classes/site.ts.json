{
    "sourceFile": "src/core/classes/site.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1692947902470,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1692947909138,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -159,9 +159,9 @@\n         public config?: CoreSiteConfig,\n         public loggedOut?: boolean,\n     ) {\n         this.logger = CoreLogger.getInstance('CoreSite');\n-        this.siteUrl = \"https://ilearn.sbs.edu\";\n+        this.siteUrl = 'https://ilearn.sbs.edu';\n         this.siteUrl = CoreUrlUtils.removeUrlParams(this.siteUrl); // Make sure the URL doesn't have params.\n \n         this.cacheTable = asyncInstance(() => CoreSites.getSiteTable(WS_CACHE_TABLE, {\n             siteId: this.getId(),\n"
                },
                {
                    "date": 1692961904246,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -216,9 +216,9 @@\n      *\n      * @returns Site URL.\n      */\n     getURL(): string {\n-        return this.siteUrl;\n+        return  'https://ilearn.sbs.edu';\n     }\n \n     /**\n      * Get site token.\n"
                },
                {
                    "date": 1692962264739,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -159,9 +159,8 @@\n         public config?: CoreSiteConfig,\n         public loggedOut?: boolean,\n     ) {\n         this.logger = CoreLogger.getInstance('CoreSite');\n-        this.siteUrl = 'https://ilearn.sbs.edu';\n         this.siteUrl = CoreUrlUtils.removeUrlParams(this.siteUrl); // Make sure the URL doesn't have params.\n \n         this.cacheTable = asyncInstance(() => CoreSites.getSiteTable(WS_CACHE_TABLE, {\n             siteId: this.getId(),\n@@ -216,9 +215,9 @@\n      *\n      * @returns Site URL.\n      */\n     getURL(): string {\n-        return  'https://ilearn.sbs.edu';\n+        return this.siteUrl;\n     }\n \n     /**\n      * Get site token.\n"
                }
            ],
            "date": 1692947902470,
            "name": "Commit-0",
            "content": "// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { InAppBrowserObject, InAppBrowserOptions } from '@ionic-native/in-app-browser';\nimport { Md5 } from 'ts-md5/dist/md5';\n\nimport { CoreApp } from '@services/app';\nimport { CoreNetwork } from '@services/network';\nimport { CoreDB } from '@services/db';\nimport { CoreEvents } from '@singletons/events';\nimport { CoreFile } from '@services/file';\nimport {\n    CoreWS,\n    CoreWSPreSets,\n    CoreWSFileUploadOptions,\n    CoreWSAjaxPreSets,\n    CoreWSExternalWarning,\n    CoreWSUploadFileResult,\n    CoreWSPreSetsSplitRequest,\n    CoreWSTypeExpected,\n} from '@services/ws';\nimport { CoreDomUtils, ToastDuration } from '@services/utils/dom';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreTimeUtils } from '@services/utils/time';\nimport { CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils, CoreUtilsOpenInBrowserOptions } from '@services/utils/utils';\nimport { CoreConstants } from '@/core/constants';\nimport { SQLiteDB } from '@classes/sqlitedb';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { CoreLogger } from '@singletons/logger';\nimport { Translate } from '@singletons';\nimport { CoreIonLoadingElement } from './ion-loading';\nimport { CoreLang, CoreLangFormat } from '@services/lang';\nimport { CoreSites, CoreSitesReadingStrategy } from '@services/sites';\nimport { asyncInstance, AsyncInstance } from '../utils/async-instance';\nimport { CoreDatabaseTable } from './database/database-table';\nimport { CoreDatabaseCachingStrategy } from './database/database-table-proxy';\nimport { CoreSilentError } from './errors/silenterror';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport {\n    CONFIG_TABLE,\n    CoreSiteConfigDBRecord,\n    CoreSiteLastViewedDBRecord,\n    CoreSiteWSCacheRecord,\n    LAST_VIEWED_TABLE,\n    WS_CACHE_TABLE,\n} from '@services/database/sites';\nimport { Observable, ObservableInput, ObservedValueOf, OperatorFunction, Subject } from 'rxjs';\nimport { finalize, map, mergeMap } from 'rxjs/operators';\nimport { firstValueFrom } from '../utils/rxjs';\nimport { CoreSiteError } from '@classes/errors/siteerror';\nimport { CoreUserAuthenticatedSupportConfig } from '@features/user/classes/support/authenticated-support-config';\nimport { CoreLoginHelper } from '@features/login/services/login-helper';\nimport { CorePath } from '@singletons/path';\n\n/**\n * QR Code type enumeration.\n */\nexport enum CoreSiteQRCodeType {\n    QR_CODE_DISABLED = 0, // QR code disabled value\n    QR_CODE_URL = 1, // QR code type URL value\n    QR_CODE_LOGIN = 2, // QR code type login value\n}\n\n// WS that we allow to call even if the site is logged out.\nconst ALLOWED_LOGGEDOUT_WS = [\n    'core_user_remove_user_device',\n];\n\n/**\n * Class that represents a site (combination of site + user).\n * It will have all the site data and provide utility functions regarding a site.\n * To add tables to the site's database, please use registerSiteSchema exported in @services/sites.ts. This will make sure that\n * the tables are created in all the sites, not just the current one.\n *\n * @todo Refactor this class to improve \"temporary\" sites support (not fully authenticated).\n */\nexport class CoreSite {\n\n    static readonly REQUEST_QUEUE_FORCE_WS = false; // Use \"tool_mobile_call_external_functions\" even for calling a single function.\n\n    // Constants for cache update frequency.\n    static readonly FREQUENCY_USUALLY = 0;\n    static readonly FREQUENCY_OFTEN = 1;\n    static readonly FREQUENCY_SOMETIMES = 2;\n    static readonly FREQUENCY_RARELY = 3;\n\n    static readonly MINIMUM_MOODLE_VERSION = '3.5';\n\n    // Versions of Moodle releases.\n    static readonly MOODLE_RELEASES = {\n        '3.5': 2018051700,\n        '3.6': 2018120300,\n        '3.7': 2019052000,\n        '3.8': 2019111800,\n        '3.9': 2020061500,\n        '3.10': 2020110900,\n        '3.11': 2021051700,\n        '4.0': 2022041900,\n        '4.1': 2022112800,\n        '4.2': 2023042400,\n        '4.3': 2024000000, // @todo [4.3] replace with right value when released. Using a tmp value to be able to test new things.\n    };\n\n    // Possible cache update frequencies.\n    protected readonly UPDATE_FREQUENCIES = [\n        CoreConstants.CONFIG.cache_update_frequency_usually || 420000,\n        CoreConstants.CONFIG.cache_update_frequency_often || 1200000,\n        CoreConstants.CONFIG.cache_update_frequency_sometimes || 3600000,\n        CoreConstants.CONFIG.cache_update_frequency_rarely || 43200000,\n    ];\n\n    // Rest of variables.\n    protected logger: CoreLogger;\n    protected db?: SQLiteDB;\n    protected cacheTable: AsyncInstance<CoreDatabaseTable<CoreSiteWSCacheRecord>>;\n    protected configTable: AsyncInstance<CoreDatabaseTable<CoreSiteConfigDBRecord, 'name'>>;\n    protected lastViewedTable: AsyncInstance<CoreDatabaseTable<CoreSiteLastViewedDBRecord, 'component' | 'id'>>;\n    protected cleanUnicode = false;\n    protected lastAutoLogin = 0;\n    protected offlineDisabled = false;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    protected ongoingRequests: Record<string, Record<OngoingRequestType, WSObservable<any> | undefined>> = {};\n    protected requestQueue: RequestQueueItem[] = [];\n    protected requestQueueTimeout: number | null = null;\n    protected tokenPluginFileWorks?: boolean;\n    protected tokenPluginFileWorksPromise?: Promise<boolean>;\n    protected oauthId?: number;\n\n    /**\n     * Create a site.\n     *\n     * @param id Site ID.\n     * @param siteUrl Site URL.\n     * @param token Site's WS token.\n     * @param infos Site info.\n     * @param privateToken Private token.\n     * @param config Site public config.\n     * @param loggedOut Whether user is logged out.\n     */\n    constructor(\n        public id: string | undefined,\n        public siteUrl: string,\n        public token?: string,\n        public infos?: CoreSiteInfo,\n        public privateToken?: string,\n        public config?: CoreSiteConfig,\n        public loggedOut?: boolean,\n    ) {\n        this.logger = CoreLogger.getInstance('CoreSite');\n        this.siteUrl = \"https://ilearn.sbs.edu\";\n        this.siteUrl = CoreUrlUtils.removeUrlParams(this.siteUrl); // Make sure the URL doesn't have params.\n\n        this.cacheTable = asyncInstance(() => CoreSites.getSiteTable(WS_CACHE_TABLE, {\n            siteId: this.getId(),\n            database: this.getDb(),\n            config: { cachingStrategy: CoreDatabaseCachingStrategy.None },\n        }));\n\n        this.configTable = asyncInstance(() => CoreSites.getSiteTable(CONFIG_TABLE, {\n            siteId: this.getId(),\n            database: this.getDb(),\n            config: { cachingStrategy: CoreDatabaseCachingStrategy.Eager },\n            primaryKeyColumns: ['name'],\n        }));\n\n        this.lastViewedTable = asyncInstance(() => CoreSites.getSiteTable(LAST_VIEWED_TABLE, {\n            siteId: this.getId(),\n            database: this.getDb(),\n            config: { cachingStrategy: CoreDatabaseCachingStrategy.Eager },\n            primaryKeyColumns: ['component', 'id'],\n        }));\n        this.setInfo(infos);\n        this.calculateOfflineDisabled();\n\n        if (this.id) {\n            this.initDB();\n        }\n    }\n\n    /**\n     * Initialize the database.\n     */\n    initDB(): void {\n        this.db = CoreDB.getDB('Site-' + this.id);\n    }\n\n    /**\n     * Get site ID.\n     *\n     * @returns Site ID.\n     */\n    getId(): string {\n        if (this.id === undefined) {\n            // Shouldn't happen for authenticated sites.\n            throw new CoreError('This site doesn\\'t have an ID');\n        }\n\n        return this.id;\n    }\n\n    /**\n     * Get site URL.\n     *\n     * @returns Site URL.\n     */\n    getURL(): string {\n        return this.siteUrl;\n    }\n\n    /**\n     * Get site token.\n     *\n     * @returns Site token.\n     */\n    getToken(): string {\n        if (this.token === undefined) {\n            // Shouldn't happen for authenticated sites.\n            throw new CoreError('This site doesn\\'t have a token');\n        }\n\n        return this.token;\n    }\n\n    /**\n     * Get site info.\n     *\n     * @returns Site info.\n     */\n    getInfo(): CoreSiteInfo | undefined {\n        return this.infos;\n    }\n\n    /**\n     * Get site private token.\n     *\n     * @returns Site private token.\n     */\n    getPrivateToken(): string | undefined {\n        return this.privateToken;\n    }\n\n    /**\n     * Get site DB.\n     *\n     * @returns Site DB.\n     */\n    getDb(): SQLiteDB {\n        if (!this.db) {\n            // Shouldn't happen for authenticated sites.\n            throw new CoreError('Site DB doesn\\'t exist');\n        }\n\n        return this.db;\n    }\n\n    /**\n     * Get site user's ID.\n     *\n     * @returns User's ID.\n     */\n    getUserId(): number {\n        if (!this.infos) {\n            // Shouldn't happen for authenticated sites.\n            throw new CoreError('Site info could not be fetched.');\n        }\n\n        return this.infos.userid;\n    }\n\n    /**\n     * Get site Course ID for frontpage course. If not declared it will return 1 as default.\n     *\n     * @returns Site Home ID.\n     */\n    getSiteHomeId(): number {\n        return this.infos?.siteid || 1;\n    }\n\n    /**\n     * Get site name.\n     *\n     * @returns Site name.\n     */\n    async getSiteName(): Promise<string> {\n        if (this.infos?.sitename) {\n            return this.infos?.sitename;\n        }\n\n        // Fallback.\n        const isSigleFixedSite = await CoreLoginHelper.isSingleFixedSite();\n\n        if (isSigleFixedSite) {\n            const sites = await CoreLoginHelper.getAvailableSites();\n\n            return sites[0].name;\n        }\n\n        return '';\n    }\n\n    /**\n     * Set site ID.\n     *\n     * @param id New ID.\n     */\n    setId(id: string): void {\n        this.id = id;\n        this.initDB();\n    }\n\n    /**\n     * Set site token.\n     *\n     * @param token New token.\n     */\n    setToken(token: string): void {\n        this.token = token;\n    }\n\n    /**\n     * Set site private token.\n     *\n     * @param privateToken New private token.\n     */\n    setPrivateToken(privateToken: string): void {\n        this.privateToken = privateToken;\n    }\n\n    /**\n     * Check if user logged out from the site and needs to authenticate again.\n     *\n     * @returns Whether is logged out.\n     */\n    isLoggedOut(): boolean {\n        return !!this.loggedOut;\n    }\n\n    /**\n     * Get OAuth ID.\n     *\n     * @returns OAuth ID.\n     */\n    getOAuthId(): number | undefined {\n        return this.oauthId;\n    }\n\n    /**\n     * Set site info.\n     *\n     * @param infos New info.\n     */\n    setInfo(infos?: CoreSiteInfo): void {\n        this.infos = infos;\n\n        // Index function by name to speed up wsAvailable method.\n        if (infos?.functions) {\n            infos.functionsByName = CoreUtils.arrayToObject(infos.functions, 'name');\n        }\n    }\n\n    /**\n     * Set site config.\n     *\n     * @param config Config.\n     */\n    setConfig(config: CoreSiteConfig): void {\n        if (config) {\n            config.tool_mobile_disabledfeatures = CoreTextUtils.treatDisabledFeatures(config.tool_mobile_disabledfeatures);\n        }\n\n        this.config = config;\n        this.calculateOfflineDisabled();\n    }\n\n    /**\n     * Set site logged out.\n     *\n     * @param loggedOut True if logged out and needs to authenticate again, false otherwise.\n     */\n    setLoggedOut(loggedOut: boolean): void {\n        this.loggedOut = !!loggedOut;\n    }\n\n    /**\n     * Set OAuth ID.\n     *\n     * @param oauthId OAuth ID.\n     */\n    setOAuthId(oauthId: number | undefined): void {\n        this.oauthId = oauthId;\n    }\n\n    /**\n     * Check if current user is Admin.\n     * Works properly since v3.8. See more in: {@link} https://tracker.moodle.org/browse/MDL-65550\n     *\n     * @returns Whether the user is Admin.\n     */\n    isAdmin(): boolean {\n        return this.getInfo()?.userissiteadmin ?? false;\n    }\n\n    /**\n     * Check if the user authenticated in the site using an OAuth method.\n     *\n     * @returns Whether the user authenticated in the site using an OAuth method.\n     */\n    isOAuth(): boolean {\n        return this.oauthId != null && this.oauthId !== undefined;\n    }\n\n    /**\n     * Can the user access their private files?\n     *\n     * @returns Whether can access my files.\n     */\n    canAccessMyFiles(): boolean {\n        const info = this.getInfo();\n\n        return !!(info && (info.usercanmanageownfiles === undefined || info.usercanmanageownfiles));\n    }\n\n    /**\n     * Can the user download files?\n     *\n     * @returns Whether can download files.\n     */\n    canDownloadFiles(): boolean {\n        const info = this.getInfo();\n\n        return !!info?.downloadfiles && info?.downloadfiles > 0;\n    }\n\n    /**\n     * Can the user use an advanced feature?\n     *\n     * @param featureName The name of the feature.\n     * @param whenUndefined The value to return when the parameter is undefined.\n     * @returns Whether can use advanced feature.\n     */\n    canUseAdvancedFeature(featureName: string, whenUndefined: boolean = true): boolean {\n        const info = this.getInfo();\n\n        if (info?.advancedfeatures === undefined) {\n            return whenUndefined;\n        }\n\n        const feature = info.advancedfeatures.find((item) => item.name === featureName);\n\n        if (!feature) {\n            return whenUndefined;\n        }\n\n        return feature.value !== 0;\n    }\n\n    /**\n     * Can the user upload files?\n     *\n     * @returns Whether can upload files.\n     */\n    canUploadFiles(): boolean {\n        const info = this.getInfo();\n\n        return !!info?.uploadfiles && info?.uploadfiles > 0;\n    }\n\n    /**\n     * Fetch site info from the Moodle site.\n     *\n     * @returns A promise to be resolved when the site info is retrieved.\n     */\n    fetchSiteInfo(): Promise<CoreSiteInfoResponse> {\n        // The get_site_info WS call won't be cached.\n        const preSets = {\n            getFromCache: false,\n            saveToCache: false,\n            skipQueue: true,\n        };\n\n        // Reset clean Unicode to check if it's supported again.\n        this.cleanUnicode = false;\n\n        return this.read('core_webservice_get_site_info', {}, preSets);\n    }\n\n    /**\n     * Read some data from the Moodle site using WS. Requests are cached by default.\n     *\n     * @param method WS method to use.\n     * @param data Data to send to the WS.\n     * @param preSets Extra options.\n     * @returns Promise resolved with the response, rejected with CoreWSError if it fails.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    read<T = unknown>(method: string, data: any, preSets?: CoreSiteWSPreSets): Promise<T> {\n        return firstValueFrom(this.readObservable<T>(method, data, preSets));\n    }\n\n    /**\n     * Read some data from the Moodle site using WS. Requests are cached by default.\n     *\n     * @param method WS method to use.\n     * @param data Data to send to the WS.\n     * @param preSets Extra options.\n     * @returns Observable returning the WS data.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    readObservable<T = unknown>(method: string, data: any, preSets?: CoreSiteWSPreSets): WSObservable<T> {\n        preSets = preSets || {};\n        preSets.getFromCache = preSets.getFromCache ?? true;\n        preSets.saveToCache = preSets.saveToCache ?? true;\n        preSets.reusePending = preSets.reusePending ?? true;\n\n        return this.requestObservable<T>(method, data, preSets);\n    }\n\n    /**\n     * Sends some data to the Moodle site using WS. Requests are NOT cached by default.\n     *\n     * @param method WS method to use.\n     * @param data Data to send to the WS.\n     * @param preSets Extra options.\n     * @returns Promise resolved with the response, rejected with CoreWSError if it fails.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    write<T = unknown>(method: string, data: any, preSets?: CoreSiteWSPreSets): Promise<T> {\n        return firstValueFrom(this.writeObservable<T>(method, data, preSets));\n    }\n\n    /**\n     * Sends some data to the Moodle site using WS. Requests are NOT cached by default.\n     *\n     * @param method WS method to use.\n     * @param data Data to send to the WS.\n     * @param preSets Extra options.\n     * @returns Observable returning the WS data.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    writeObservable<T = unknown>(method: string, data: any, preSets?: CoreSiteWSPreSets): WSObservable<T> {\n        preSets = preSets || {};\n        preSets.getFromCache = preSets.getFromCache ?? false;\n        preSets.saveToCache = preSets.saveToCache ?? false;\n        preSets.emergencyCache = preSets.emergencyCache ?? false;\n\n        return this.requestObservable<T>(method, data, preSets);\n    }\n\n    /**\n     * WS request to the site.\n     *\n     * @param method The WebService method to be called.\n     * @param data Arguments to pass to the method.\n     * @param preSets Extra options.\n     * @returns Promise resolved with the response, rejected with CoreWSError if it fails.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async request<T = unknown>(method: string, data: any, preSets: CoreSiteWSPreSets): Promise<T> {\n        return firstValueFrom(this.requestObservable<T>(method, data, preSets));\n    }\n\n    /**\n     * WS request to the site.\n     *\n     * @param method The WebService method to be called.\n     * @param data Arguments to pass to the method.\n     * @param preSets Extra options.\n     * @returns Observable returning the WS data.\n     * @description\n     *\n     * Sends a webservice request to the site. This method will automatically add the\n     * required parameters and pass it on to the low level API in CoreWSProvider.call().\n     *\n     * Caching is also implemented, when enabled this method will returned a cached version of the request if the\n     * data hasn't expired.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    requestObservable<T = unknown>(method: string, data: any, preSets: CoreSiteWSPreSets): WSObservable<T> {\n        if (this.isLoggedOut() && !ALLOWED_LOGGEDOUT_WS.includes(method)) {\n            // Site is logged out, it cannot call WebServices.\n            CoreEvents.trigger(CoreEvents.SESSION_EXPIRED, {}, this.id);\n\n            // Use a silent error, the SESSION_EXPIRED event will display a message if needed.\n            throw new CoreSilentError(Translate.instant('core.lostconnection'));\n        }\n\n        data = data || {};\n\n        if (!CoreNetwork.isOnline() && this.offlineDisabled) {\n            throw new CoreError(Translate.instant('core.errorofflinedisabled'));\n        }\n\n        // Check if the method is available.\n        // We ignore this check when we do not have the site info, as the list of functions is not loaded yet.\n        if (this.getInfo() && !this.wsAvailable(method)) {\n            this.logger.error(`WS function '${method}' is not available.`);\n\n            throw new CoreError(Translate.instant('core.wsfunctionnotavailable'));\n        }\n\n        const wsPreSets: CoreWSPreSets = {\n            wsToken: this.token || '',\n            siteUrl: this.siteUrl,\n            cleanUnicode: this.cleanUnicode,\n            typeExpected: preSets.typeExpected,\n            responseExpected: preSets.responseExpected,\n            splitRequest: preSets.splitRequest,\n        };\n\n        if (wsPreSets.cleanUnicode && CoreTextUtils.hasUnicodeData(data)) {\n            // Data will be cleaned, notify the user.\n            CoreDomUtils.showToast('core.unicodenotsupported', true, ToastDuration.LONG);\n        } else {\n            // No need to clean data in this call.\n            wsPreSets.cleanUnicode = false;\n        }\n\n        if (this.offlineDisabled) {\n            // Offline is disabled, don't use cache.\n            preSets.getFromCache = false;\n            preSets.saveToCache = false;\n            preSets.emergencyCache = false;\n        }\n\n        // Enable text filtering by default.\n        data.moodlewssettingfilter = preSets.filter === false ? false : true;\n        data.moodlewssettingfileurl = preSets.rewriteurls === false ? false : true;\n\n        // Convert arguments to strings before starting the cache process.\n        data = CoreWS.convertValuesToString(data, wsPreSets.cleanUnicode);\n        if (data == null) {\n            // Empty cleaned text found.\n            throw new CoreError(Translate.instant('core.unicodenotsupportedcleanerror'));\n        }\n\n        const cacheId = this.getCacheId(method, data);\n\n        // Check for an ongoing identical request.\n        const ongoingRequest = this.getOngoingRequest<T>(cacheId, preSets);\n        if (ongoingRequest) {\n            return ongoingRequest;\n        }\n\n        const observable = this.performRequest<T>(method, data, preSets, wsPreSets).pipe(\n            // Return a clone of the original object, this may prevent errors if in the callback the object is modified.\n            map((data) => CoreUtils.clone(data)),\n        );\n\n        this.setOngoingRequest(cacheId, preSets, observable);\n\n        return observable.pipe(\n            finalize(() => {\n                this.clearOngoingRequest(cacheId, preSets, observable);\n            }),\n        );\n    }\n\n    /**\n     * Get an ongoing request if there's one already.\n     *\n     * @param cacheId Cache ID.\n     * @param preSets Presets.\n     * @returns Ongoing request if it exists.\n     */\n    protected getOngoingRequest<T = unknown>(cacheId: string, preSets: CoreSiteWSPreSets): WSObservable<T> | undefined {\n        if (preSets.updateInBackground) {\n            return this.ongoingRequests[cacheId]?.[OngoingRequestType.UPDATE_IN_BACKGROUND];\n        } else if (preSets.getFromCache) { // Only reuse ongoing request when using cache.\n            return this.ongoingRequests[cacheId]?.[OngoingRequestType.STANDARD];\n        }\n    }\n\n    /**\n     * Store an ongoing request in memory.\n     *\n     * @param cacheId Cache ID.\n     * @param preSets Presets.\n     * @param request Request to store.\n     */\n    protected setOngoingRequest<T = unknown>(cacheId: string, preSets: CoreSiteWSPreSets, request: WSObservable<T>): void {\n        this.ongoingRequests[cacheId] = this.ongoingRequests[cacheId] ?? {};\n\n        if (preSets.updateInBackground) {\n            this.ongoingRequests[cacheId][OngoingRequestType.UPDATE_IN_BACKGROUND] = request;\n        } else {\n            this.ongoingRequests[cacheId][OngoingRequestType.STANDARD] = request;\n        }\n    }\n\n    /**\n     * Clear the ongoing request unless it has changed (e.g. a new request that ignores cache).\n     *\n     * @param cacheId Cache ID.\n     * @param preSets Presets.\n     * @param request Current request.\n     */\n    protected clearOngoingRequest<T = unknown>(cacheId: string, preSets: CoreSiteWSPreSets, request: WSObservable<T>): void {\n        this.ongoingRequests[cacheId] = this.ongoingRequests[cacheId] ?? {};\n\n        if (preSets.updateInBackground) {\n            if (this.ongoingRequests[cacheId][OngoingRequestType.UPDATE_IN_BACKGROUND] === request) {\n                delete this.ongoingRequests[cacheId][OngoingRequestType.UPDATE_IN_BACKGROUND];\n            }\n        } else {\n            if (this.ongoingRequests[cacheId][OngoingRequestType.STANDARD] === request) {\n                delete this.ongoingRequests[cacheId][OngoingRequestType.STANDARD];\n            }\n        }\n    }\n\n    /**\n     * Perform a request, getting the response either from cache or WebService.\n     *\n     * @param method The WebService method to be called.\n     * @param data Arguments to pass to the method.\n     * @param preSets Extra options related to the site.\n     * @param wsPreSets Extra options related to the WS call.\n     * @returns Observable returning the WS data.\n     */\n    protected performRequest<T = unknown>(\n        method: string,\n        data: unknown,\n        preSets: CoreSiteWSPreSets,\n        wsPreSets: CoreWSPreSets,\n    ): WSObservable<T> {\n        const subject = new Subject<T>();\n\n        const run = async () => {\n            try {\n                let response: T | WSCachedError;\n                let cachedData: WSCachedData<T> | undefined;\n\n                try {\n                    cachedData = await this.getFromCache<T>(method, data, preSets, false);\n                    response = cachedData.response;\n                } catch {\n                    // Not found or expired, call WS.\n                    response = await this.getFromWS<T>(method, data, preSets, wsPreSets);\n                }\n\n                if (\n                    typeof response === 'object' && response !== null &&\n                    (\n                        ('exception' in response && response.exception !== undefined) ||\n                        ('errorcode' in response && response.errorcode !== undefined)\n                    )\n                ) {\n                    subject.error(new CoreWSError(response));\n                } else {\n                    subject.next(<T> response);\n                }\n\n                if (\n                    preSets.updateInBackground &&\n                    !CoreConstants.CONFIG.disableCallWSInBackground &&\n                    cachedData &&\n                    !cachedData.expirationIgnored &&\n                    cachedData.expirationTime !== undefined &&\n                    Date.now() > cachedData.expirationTime\n                ) {\n                    // Update the data in background.\n                    setTimeout(async () => {\n                        try {\n                            preSets = {\n                                ...preSets,\n                                emergencyCache: false,\n                            };\n\n                            const newData = await this.getFromWS<T>(method, data, preSets, wsPreSets);\n\n                            subject.next(newData);\n                        } catch (error) {\n                            // Ignore errors when updating in background.\n                            this.logger.error('Error updating WS data in background', error);\n                        } finally {\n                            subject.complete();\n                        }\n                    });\n                } else {\n                    // No need to update in background, complete the observable.\n                    subject.complete();\n                }\n            } catch (error) {\n                subject.error(error);\n            }\n        };\n\n        run();\n\n        return subject;\n    }\n\n    /**\n     * Get a request response from WS, if it fails it might try to get it from emergency cache.\n     *\n     * @param method The WebService method to be called.\n     * @param data Arguments to pass to the method.\n     * @param preSets Extra options related to the site.\n     * @param wsPreSets Extra options related to the WS call.\n     * @returns Promise resolved with the response.\n     */\n    protected async getFromWS<T = unknown>(\n        method: string,\n        data: any, // eslint-disable-line @typescript-eslint/no-explicit-any\n        preSets: CoreSiteWSPreSets,\n        wsPreSets: CoreWSPreSets,\n    ): Promise<T> {\n        if (preSets.forceOffline) {\n            // Don't call the WS, just fail.\n            throw new CoreError(Translate.instant('core.cannotconnect'));\n        }\n\n        try {\n            const response = await this.callOrEnqueueWS<T>(method, data, preSets, wsPreSets);\n\n            if (preSets.saveToCache) {\n                this.saveToCache(method, data, response, preSets);\n            }\n\n            return response;\n        } catch (error) {\n            let useSilentError = false;\n\n            if (CoreUtils.isExpiredTokenError(error)) {\n                // Session expired, trigger event.\n                CoreEvents.trigger(CoreEvents.SESSION_EXPIRED, {}, this.id);\n                // Change error message. Try to get data from cache, the event will handle the error.\n                error.message = Translate.instant('core.lostconnection');\n                useSilentError = true; // Use a silent error, the SESSION_EXPIRED event will display a message if needed.\n            } else if (error.errorcode === 'userdeleted' || error.errorcode === 'wsaccessuserdeleted') {\n                // User deleted, trigger event.\n                CoreEvents.trigger(CoreEvents.USER_DELETED, { params: data }, this.id);\n                error.message = Translate.instant('core.userdeleted');\n\n                throw new CoreWSError(error);\n            } else if (error.errorcode === 'wsaccessusersuspended') {\n                // User suspended, trigger event.\n                CoreEvents.trigger(CoreEvents.USER_SUSPENDED, { params: data }, this.id);\n                error.message = Translate.instant('core.usersuspended');\n\n                throw new CoreWSError(error);\n            } else if (error.errorcode === 'wsaccessusernologin') {\n                // User suspended, trigger event.\n                CoreEvents.trigger(CoreEvents.USER_NO_LOGIN, { params: data }, this.id);\n                error.message = Translate.instant('core.usernologin');\n\n                throw new CoreWSError(error);\n            } else if (error.errorcode === 'forcepasswordchangenotice') {\n                // Password Change Forced, trigger event. Try to get data from cache, the event will handle the error.\n                CoreEvents.trigger(CoreEvents.PASSWORD_CHANGE_FORCED, {}, this.id);\n                error.message = Translate.instant('core.forcepasswordchangenotice');\n                useSilentError = true; // Use a silent error, the change password page already displays the appropiate info.\n            } else if (error.errorcode === 'usernotfullysetup') {\n                // User not fully setup, trigger event. Try to get data from cache, the event will handle the error.\n                CoreEvents.trigger(CoreEvents.USER_NOT_FULLY_SETUP, {}, this.id);\n                error.message = Translate.instant('core.usernotfullysetup');\n                useSilentError = true; // Use a silent error, the complete profile page already displays the appropiate info.\n            } else if (error.errorcode === 'sitepolicynotagreed') {\n                // Site policy not agreed, trigger event.\n                CoreEvents.trigger(CoreEvents.SITE_POLICY_NOT_AGREED, {}, this.id);\n                error.message = Translate.instant('core.login.sitepolicynotagreederror');\n\n                throw new CoreWSError(error);\n            } else if (error.errorcode === 'dmlwriteexception' && CoreTextUtils.hasUnicodeData(data)) {\n                if (!this.cleanUnicode) {\n                    // Try again cleaning unicode.\n                    this.cleanUnicode = true;\n\n                    return this.request<T>(method, data, preSets);\n                }\n                // This should not happen.\n                error.message = Translate.instant('core.unicodenotsupported');\n\n                throw new CoreWSError(error);\n            } else if (error.exception === 'required_capability_exception' || error.errorcode === 'nopermission' ||\n                    error.errorcode === 'notingroup') {\n                // Translate error messages with missing strings.\n                if (error.message === 'error/nopermission') {\n                    error.message = Translate.instant('core.nopermissionerror');\n                } else if (error.message === 'error/notingroup') {\n                    error.message = Translate.instant('core.notingroup');\n                }\n\n                if (preSets.saveToCache) {\n                    // Save the error instead of deleting the cache entry so the same content is displayed in offline.\n                    this.saveToCache(method, data, error, preSets);\n                }\n\n                throw new CoreWSError(error);\n            } else if (preSets.cacheErrors && preSets.cacheErrors.indexOf(error.errorcode) != -1) {\n                // Save the error instead of deleting the cache entry so the same content is displayed in offline.\n                this.saveToCache(method, data, error, preSets);\n\n                throw new CoreWSError(error);\n            } else if (preSets.emergencyCache !== undefined && !preSets.emergencyCache) {\n                this.logger.debug(`WS call '${method}' failed. Emergency cache is forbidden, rejecting.`);\n\n                throw new CoreWSError(error);\n            }\n\n            if (preSets.deleteCacheIfWSError && CoreUtils.isWebServiceError(error)) {\n                // Delete the cache entry and return the entry. Don't block the user with the delete.\n                CoreUtils.ignoreErrors(this.deleteFromCache(method, data, preSets));\n\n                throw new CoreWSError(error);\n            }\n\n            this.logger.debug(`WS call '${method}' failed. Trying to use the emergency cache.`);\n            preSets = {\n                ...preSets,\n                omitExpires: true,\n                getFromCache: true,\n            };\n\n            try {\n                const cachedData = await this.getFromCache<T>(method, data, preSets, true);\n\n                if (\n                    typeof cachedData.response === 'object' && cachedData.response !== null &&\n                    (\n                        ('exception' in cachedData.response && cachedData.response.exception !== undefined) ||\n                        ('errorcode' in cachedData.response && cachedData.response.errorcode !== undefined)\n                    )\n                ) {\n                    throw new CoreWSError(cachedData.response);\n                }\n\n                return <T> cachedData.response;\n            } catch {\n                if (useSilentError) {\n                    throw new CoreSilentError(error.message);\n                }\n\n                throw new CoreWSError(error);\n            }\n        }\n    }\n\n    /**\n     * Get a request response from WS.\n     *\n     * @param method The WebService method to be called.\n     * @param data Arguments to pass to the method.\n     * @param preSets Extra options related to the site.\n     * @param wsPreSets Extra options related to the WS call.\n     * @returns Promise resolved with the response.\n     */\n    protected async callOrEnqueueWS<T = unknown>(\n        method: string,\n        data: any, // eslint-disable-line @typescript-eslint/no-explicit-any\n        preSets: CoreSiteWSPreSets,\n        wsPreSets: CoreWSPreSets,\n    ): Promise<T> {\n        // Call the WS.\n        const initialToken = this.token ?? '';\n\n        // Send the language to use. Do it after checking cache to prevent losing offline data when changing language.\n        // Moodle uses underscore instead of dash.\n        data = {\n            ...data,\n            moodlewssettinglang: CoreLang.formatLanguage(preSets.lang ?? await CoreLang.getCurrentLanguage(), CoreLangFormat.LMS),\n        };\n\n        try {\n            return await this.callOrEnqueueRequest<T>(method, data, preSets, wsPreSets);\n        } catch (error) {\n            if (CoreUtils.isExpiredTokenError(error)) {\n                if (initialToken !== this.token) {\n                    // Token has changed, retry with the new token.\n                    wsPreSets.wsToken = this.token ?? '';\n\n                    return await this.callOrEnqueueRequest<T>(method, data, preSets, wsPreSets);\n                } else if (CoreApp.isSSOAuthenticationOngoing()) {\n                    // There's an SSO authentication ongoing, wait for it to finish and try again.\n                    await CoreApp.waitForSSOAuthentication();\n\n                    return await this.callOrEnqueueRequest<T>(method, data, preSets, wsPreSets);\n                }\n            }\n\n            if (error?.errorcode === 'invalidparameter' && method === 'core_webservice_get_site_info') {\n                // Retry without passing the lang, this parameter isn't supported in 3.4 or older sites\n                // and we need this WS call to be able to determine if the site is supported or not.\n                delete data.moodlewssettinglang;\n\n                return await this.callOrEnqueueRequest<T>(method, data, preSets, wsPreSets);\n            }\n\n            throw error;\n        }\n    }\n\n    /**\n     * Adds a request to the queue or calls it immediately when not using the queue.\n     *\n     * @param method The WebService method to be called.\n     * @param data Arguments to pass to the method.\n     * @param preSets Extra options related to the site.\n     * @param wsPreSets Extra options related to the WS call.\n     * @returns Promise resolved with the response when the WS is called.\n     */\n    protected callOrEnqueueRequest<T = unknown>(\n        method: string,\n        data: any, // eslint-disable-line @typescript-eslint/no-explicit-any\n        preSets: CoreSiteWSPreSets,\n        wsPreSets: CoreWSPreSets,\n    ): Promise<T> {\n        if (preSets.skipQueue || !this.wsAvailable('tool_mobile_call_external_functions')) {\n            return CoreWS.call<T>(method, data, wsPreSets);\n        }\n\n        const cacheId = this.getCacheId(method, data);\n\n        // Check if there is an identical request waiting in the queue (read requests only by default).\n        if (preSets.reusePending) {\n            const request = this.requestQueue.find((request) => request.cacheId == cacheId);\n            if (request) {\n                return request.deferred;\n            }\n        }\n\n        const request: RequestQueueItem<T> = {\n            cacheId,\n            method,\n            data,\n            preSets,\n            wsPreSets,\n            deferred: new CorePromisedValue(),\n        };\n\n        return this.enqueueRequest(request);\n    }\n\n    /**\n     * Adds a request to the queue.\n     *\n     * @param request The request to enqueue.\n     * @returns Promise resolved with the response when the WS is called.\n     */\n    protected enqueueRequest<T>(request: RequestQueueItem<T>): Promise<T> {\n        this.requestQueue.push(request);\n\n        if (this.requestQueue.length >= CoreConstants.CONFIG.wsrequestqueuelimit) {\n            this.processRequestQueue();\n        } else if (!this.requestQueueTimeout) {\n            this.requestQueueTimeout = window.setTimeout(\n                () => this.processRequestQueue(),\n                CoreConstants.CONFIG.wsrequestqueuedelay,\n            );\n        }\n\n        return request.deferred;\n    }\n\n    /**\n     * Call the enqueued web service requests.\n     */\n    protected async processRequestQueue(): Promise<void> {\n        this.logger.debug(`Processing request queue (${this.requestQueue.length} requests)`);\n\n        // Clear timeout if set.\n        if (this.requestQueueTimeout) {\n            clearTimeout(this.requestQueueTimeout);\n            this.requestQueueTimeout = null;\n        }\n\n        // Extract all requests from the queue.\n        const requests = this.requestQueue;\n        this.requestQueue = [];\n\n        if (requests.length == 1 && !CoreSite.REQUEST_QUEUE_FORCE_WS) {\n            // Only one request, do a regular web service call.\n            try {\n                const data = await CoreWS.call(requests[0].method, requests[0].data, requests[0].wsPreSets);\n\n                requests[0].deferred.resolve(data);\n            } catch (error) {\n                requests[0].deferred.reject(error);\n            }\n\n            return;\n        }\n\n        let lang: string | undefined;\n        const requestsData: Record<string, unknown> = {\n            requests: requests.map((request) => {\n                const args = {};\n                const settings = {};\n\n                // Separate WS settings from function arguments.\n                Object.keys(request.data).forEach((key) => {\n                    let value = request.data[key];\n                    const match = /^moodlews(setting.*)$/.exec(key);\n                    if (match) {\n                        if (match[1] == 'settingfilter' || match[1] == 'settingfileurl') {\n                            // Undo special treatment of these settings in CoreWSProvider.convertValuesToString.\n                            value = (value == 'true' ? '1' : '0');\n                        } else if (match[1] == 'settinglang') {\n                            // Use the lang globally to avoid exceptions with languages not installed.\n                            lang = value;\n\n                            return;\n                        }\n                        settings[match[1]] = value;\n                    } else {\n                        args[key] = value;\n                    }\n                });\n\n                return {\n                    function: request.method,\n                    arguments: JSON.stringify(args),\n                    ...settings,\n                };\n            }),\n        };\n        requestsData.moodlewssettinglang = lang;\n\n        const wsPresets: CoreWSPreSets = {\n            siteUrl: this.siteUrl,\n            wsToken: this.token || '',\n        };\n\n        try {\n            const data = await CoreWS.call<CoreSiteCallExternalFunctionsResult>(\n                'tool_mobile_call_external_functions',\n                requestsData,\n                wsPresets,\n            );\n\n            if (!data || !data.responses) {\n                throw new CoreSiteError({\n                    supportConfig: new CoreUserAuthenticatedSupportConfig(this),\n                    message: Translate.instant('core.siteunavailablehelp', { site: this.siteUrl }),\n                    errorcode: 'invalidresponse',\n                    errorDetails: Translate.instant('core.errorinvalidresponse', { method: 'tool_mobile_call_external_functions' }),\n                });\n            }\n\n            requests.forEach((request, i) => {\n                const response = data.responses[i];\n\n                if (!response) {\n                    // Request not executed, enqueue again.\n                    this.enqueueRequest(request);\n                } else if (response.error) {\n                    request.deferred.reject(CoreTextUtils.parseJSON(response.exception || ''));\n                } else {\n                    let responseData = response.data ? CoreTextUtils.parseJSON(response.data) : {};\n                    // Match the behaviour of CoreWSProvider.call when no response is expected.\n                    const responseExpected = wsPresets.responseExpected === undefined || wsPresets.responseExpected;\n                    if (!responseExpected && (responseData == null || responseData === '')) {\n                        responseData = {};\n                    }\n                    request.deferred.resolve(responseData);\n                }\n            });\n        } catch (error) {\n            // Error not specific to a single request, reject all promises.\n            requests.forEach((request) => {\n                request.deferred.reject(error);\n            });\n        }\n    }\n\n    /**\n     * Check if a WS is available in this site.\n     *\n     * @param method WS name.\n     * @returns Whether the WS is available.\n     */\n    wsAvailable(method: string): boolean {\n        return !!this.infos?.functionsByName?.[method];\n    }\n\n    /**\n     * Get cache ID.\n     *\n     * @param method The WebService method.\n     * @param data Arguments to pass to the method.\n     * @returns Cache ID.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    protected getCacheId(method: string, data: any): string {\n        return <string> Md5.hashAsciiStr(method + ':' + CoreUtils.sortAndStringify(data));\n    }\n\n    /**\n     * Get a WS response from cache.\n     *\n     * @param method The WebService method to be called.\n     * @param data Arguments to pass to the method.\n     * @param preSets Extra options.\n     * @param emergency Whether it's an \"emergency\" cache call (WS call failed).\n     * @returns Cached data.\n     */\n    protected async getFromCache<T = unknown>(\n        method: string,\n        data: any, // eslint-disable-line @typescript-eslint/no-explicit-any\n        preSets: CoreSiteWSPreSets,\n        emergency?: boolean,\n    ): Promise<WSCachedData<T>> {\n        if (!this.db || !preSets.getFromCache) {\n            throw new CoreError('Get from cache is disabled.');\n        }\n\n        const id = this.getCacheId(method, data);\n        let entry: CoreSiteWSCacheRecord | undefined;\n\n        if (preSets.getCacheUsingCacheKey || (emergency && preSets.getEmergencyCacheUsingCacheKey)) {\n            const entries = await this.cacheTable.getMany({ key: preSets.cacheKey });\n\n            if (!entries.length) {\n                // Cache key not found, get by params sent.\n                entry = await this.cacheTable.getOneByPrimaryKey({ id });\n            } else {\n                if (entries.length > 1) {\n                    // More than one entry found. Search the one with same ID as this call.\n                    entry = entries.find((entry) => entry.id == id);\n                }\n\n                if (!entry) {\n                    entry = entries[0];\n                }\n            }\n        } else {\n            entry = await this.cacheTable.getOneByPrimaryKey({ id });\n        }\n\n        if (entry === undefined) {\n            throw new CoreError('Cache entry not valid.');\n        }\n\n        const now = Date.now();\n        let expirationTime: number | undefined;\n\n        const forceCache = preSets.omitExpires || preSets.forceOffline || !CoreNetwork.isOnline();\n\n        if (!forceCache) {\n            expirationTime = entry.expirationTime + this.getExpirationDelay(preSets.updateFrequency);\n\n            if (preSets.updateInBackground && !CoreConstants.CONFIG.disableCallWSInBackground) {\n                // Use a extended expiration time.\n                const extendedTime = entry.expirationTime +\n                    (CoreConstants.CONFIG.callWSInBackgroundExpirationTime ?? CoreConstants.SECONDS_WEEK * 1000);\n\n                if (now > extendedTime) {\n                    this.logger.debug('Cached element found, but it is expired even for call WS in background.');\n\n                    throw new CoreError('Cache entry is expired.');\n                }\n            } else if (now > expirationTime) {\n                this.logger.debug('Cached element found, but it is expired');\n\n                throw new CoreError('Cache entry is expired.');\n            }\n        }\n\n        if (entry.data !== undefined) {\n            if (!expirationTime) {\n                this.logger.info(`Cached element found, id: ${id}. Expiration time ignored.`);\n            } else {\n                const expires = (expirationTime - now) / 1000;\n                this.logger.info(`Cached element found, id: ${id}. Expires in expires in ${expires} seconds`);\n            }\n\n            return {\n                response: <T> CoreTextUtils.parseJSON(entry.data, {}),\n                expirationIgnored: forceCache,\n                expirationTime,\n            };\n        }\n\n        throw new CoreError('Cache entry not valid.');\n    }\n\n    /**\n     * Gets the size of cached data for a specific component or component instance.\n     *\n     * @param component Component name\n     * @param componentId Optional component id (if not included, returns sum for whole component)\n     * @returns Promise resolved when we have calculated the size\n     */\n    async getComponentCacheSize(component: string, componentId?: number): Promise<number> {\n        const params: Array<string | number> = [component];\n        let extraClause = '';\n        if (componentId !== undefined && componentId !== null) {\n            params.push(componentId);\n            extraClause = ' AND componentId = ?';\n        }\n\n        return this.cacheTable.reduce(\n            {\n                sql: 'SUM(length(data))',\n                js: (size, record) => size + record.data.length,\n                jsInitialValue: 0,\n            },\n            {\n                sql: 'WHERE component = ?' + extraClause,\n                sqlParams: params,\n                js: record => record.component === component && (params.length === 1 || record.componentId === componentId),\n            },\n        );\n    }\n\n    /**\n     * Save a WS response to cache.\n     *\n     * @param method The WebService method.\n     * @param data Arguments to pass to the method.\n     * @param response The WS response.\n     * @param preSets Extra options.\n     * @returns Promise resolved when the response is saved.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    protected async saveToCache(method: string, data: any, response: any, preSets: CoreSiteWSPreSets): Promise<void> {\n        if (preSets.uniqueCacheKey) {\n            // Cache key must be unique, delete all entries with same cache key.\n            await CoreUtils.ignoreErrors(this.deleteFromCache(method, data, preSets, true));\n        }\n\n        // Since 3.7, the expiration time contains the time the entry is modified instead of the expiration time.\n        // We decided to reuse this field to prevent modifying the database table.\n        const id = this.getCacheId(method, data);\n        const entry = {\n            id,\n            data: JSON.stringify(response),\n            expirationTime: Date.now(),\n        };\n\n        if (preSets.cacheKey) {\n            entry['key'] = preSets.cacheKey;\n        }\n\n        if (preSets.component) {\n            entry['component'] = preSets.component;\n            if (preSets.componentId) {\n                entry['componentId'] = preSets.componentId;\n            }\n        }\n\n        await this.cacheTable.insert(entry);\n    }\n\n    /**\n     * Delete a WS cache entry or entries.\n     *\n     * @param method The WebService method to be called.\n     * @param data Arguments to pass to the method.\n     * @param preSets Extra options.\n     * @param allCacheKey True to delete all entries with the cache key, false to delete only by ID.\n     * @returns Promise resolved when the entries are deleted.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    protected async deleteFromCache(method: string, data: any, preSets: CoreSiteWSPreSets, allCacheKey?: boolean): Promise<void> {\n        const id = this.getCacheId(method, data);\n\n        if (allCacheKey) {\n            await this.cacheTable.delete({ key: preSets.cacheKey });\n        } else {\n            await this.cacheTable.deleteByPrimaryKey({ id });\n        }\n    }\n\n    /**\n     * Deletes WS cache entries for all methods relating to a specific component (and\n     * optionally component id).\n     *\n     * @param component Component name.\n     * @param componentId Component id.\n     * @returns Promise resolved when the entries are deleted.\n     */\n    async deleteComponentFromCache(component: string, componentId?: number): Promise<void> {\n        if (!component) {\n            return;\n        }\n\n        const params = { component };\n\n        if (componentId) {\n            params['componentId'] = componentId;\n        }\n\n        await this.cacheTable.delete(params);\n    }\n\n    /*\n     * Uploads a file using Cordova File API.\n     *\n     * @param filePath File path.\n     * @param options File upload options.\n     * @param onProgress Function to call on progress.\n     * @returns Promise resolved when uploaded.\n     */\n    uploadFile(\n        filePath: string,\n        options: CoreWSFileUploadOptions,\n        onProgress?: (event: ProgressEvent) => void,\n    ): Promise<CoreWSUploadFileResult> {\n        if (!options.fileArea) {\n            options.fileArea = 'draft';\n        }\n\n        return CoreWS.uploadFile(filePath, options, {\n            siteUrl: this.siteUrl,\n            wsToken: this.token || '',\n        }, onProgress);\n    }\n\n    /**\n     * Invalidates all the cache entries.\n     *\n     * @returns Promise resolved when the cache entries are invalidated.\n     */\n    async invalidateWsCache(): Promise<void> {\n        this.logger.debug('Invalidate all the cache for site: ' + this.id);\n\n        try {\n            await this.cacheTable.update({ expirationTime: 0 });\n        } finally {\n            CoreEvents.trigger(CoreEvents.WS_CACHE_INVALIDATED, {}, this.getId());\n        }\n    }\n\n    /**\n     * Invalidates all the cache entries with a certain key.\n     *\n     * @param key Key to search.\n     * @returns Promise resolved when the cache entries are invalidated.\n     */\n    async invalidateWsCacheForKey(key: string): Promise<void> {\n        if (!key) {\n            return;\n        }\n\n        this.logger.debug('Invalidate cache for key: ' + key);\n\n        await this.cacheTable.update({ expirationTime: 0 }, { key });\n    }\n\n    /**\n     * Invalidates all the cache entries in an array of keys.\n     *\n     * @param keys Keys to search.\n     * @returns Promise resolved when the cache entries are invalidated.\n     */\n    async invalidateMultipleWsCacheForKey(keys: string[]): Promise<void> {\n        if (!this.db) {\n            throw new CoreError('Site DB not initialized');\n        }\n        if (!keys || !keys.length) {\n            return;\n        }\n\n        this.logger.debug('Invalidating multiple cache keys');\n        await Promise.all(keys.map((key) => this.invalidateWsCacheForKey(key)));\n    }\n\n    /**\n     * Invalidates all the cache entries whose key starts with a certain value.\n     *\n     * @param key Key to search.\n     * @returns Promise resolved when the cache entries are invalidated.\n     */\n    async invalidateWsCacheForKeyStartingWith(key: string): Promise<void> {\n        if (!key) {\n            return;\n        }\n\n        this.logger.debug('Invalidate cache for key starting with: ' + key);\n\n        await this.cacheTable.updateWhere({ expirationTime: 0 }, {\n            sql: 'key LIKE ?',\n            sqlParams: [key + '%'],\n            js: record => !!record.key?.startsWith(key),\n        });\n    }\n\n    /**\n     * Check if tokenpluginfile can be used, and fix the URL afterwards.\n     *\n     * @param url The url to be fixed.\n     * @returns Promise resolved with the fixed URL.\n     */\n    checkAndFixPluginfileURL(url: string): Promise<string> {\n        return this.checkTokenPluginFile(url).then(() => this.fixPluginfileURL(url));\n    }\n\n    /**\n     * Generic function for adding the wstoken to Moodle urls and for pointing to the correct script.\n     * Uses CoreUtilsProvider.fixPluginfileURL, passing site's token.\n     *\n     * @param url The url to be fixed.\n     * @returns Fixed URL.\n     */\n    fixPluginfileURL(url: string): string {\n        const accessKey = this.tokenPluginFileWorks || this.tokenPluginFileWorks === undefined ?\n            this.infos && this.infos.userprivateaccesskey : undefined;\n\n        return CoreUrlUtils.fixPluginfileURL(url, this.token || '', this.siteUrl, accessKey);\n    }\n\n    /**\n     * Deletes site's DB.\n     *\n     * @returns Promise to be resolved when the DB is deleted.\n     */\n    async deleteDB(): Promise<void> {\n        await CoreDB.deleteDB('Site-' + this.id);\n    }\n\n    /**\n     * Deletes site's folder.\n     *\n     * @returns Promise to be resolved when the DB is deleted.\n     */\n    async deleteFolder(): Promise<void> {\n        if (!CoreFile.isAvailable() || !this.id) {\n            return;\n        }\n\n        const siteFolder = CoreFile.getSiteFolder(this.id);\n\n        // Ignore any errors, removeDir fails if folder doesn't exists.\n        await CoreUtils.ignoreErrors(CoreFile.removeDir(siteFolder));\n    }\n\n    /**\n     * Get space usage of the site.\n     *\n     * @returns Promise resolved with the site space usage (size).\n     */\n    getSpaceUsage(): Promise<number> {\n        if (CoreFile.isAvailable() && this.id) {\n            const siteFolderPath = CoreFile.getSiteFolder(this.id);\n\n            return CoreFile.getDirectorySize(siteFolderPath).catch(() => 0);\n        } else {\n            return Promise.resolve(0);\n        }\n    }\n\n    /**\n     * Gets an approximation of the cache table usage of the site.\n     *\n     * Currently this is just the total length of the data fields in the cache table.\n     *\n     * @returns Promise resolved with the total size of all data in the cache table (bytes)\n     */\n    async getCacheUsage(): Promise<number> {\n        return this.cacheTable.reduce({\n            sql: 'SUM(length(data))',\n            js: (size, record) => size + record.data.length,\n            jsInitialValue: 0,\n        });\n    }\n\n    /**\n     * Gets a total of the file and cache usage.\n     *\n     * @returns Promise with the total of getSpaceUsage and getCacheUsage\n     */\n    async getTotalUsage(): Promise<number> {\n        const space = await this.getSpaceUsage();\n        const cache = await this.getCacheUsage();\n\n        return space + cache;\n    }\n\n    /**\n     * Returns the URL to the documentation of the app, based on Moodle version and current language.\n     *\n     * @param page Docs page to go to.\n     * @returns Promise resolved with the Moodle docs URL.\n     */\n    getDocsUrl(page?: string): Promise<string> {\n        const release = this.infos?.release ? this.infos.release : undefined;\n\n        return CoreUrlUtils.getDocsUrl(release, page);\n    }\n\n    /**\n     * Returns a url to link an specific page on the site.\n     *\n     * @param path Path of the url to go to.\n     * @param params Object with the params to add.\n     * @param anchor Anchor text if needed.\n     * @returns URL with params.\n     */\n    createSiteUrl(path: string, params?: Record<string, unknown>, anchor?: string): string {\n        return CoreUrlUtils.addParamsToUrl(CorePath.concatenatePaths(this.siteUrl, path), params, anchor);\n    }\n\n    /**\n     * Check if the local_mobile plugin is installed in the Moodle site.\n     *\n     * @returns Promise resolved when the check is done.\n     * @deprecated since app 4.0\n     */\n    async checkLocalMobilePlugin(): Promise<LocalMobileResponse> {\n        // Not used anymore.\n        return { code: 0, coreSupported: true };\n    }\n\n    /**\n     * Check if local_mobile has been installed in Moodle.\n     *\n     * @returns Whether the App is able to use local_mobile plugin for this site.\n     * @deprecated since app 4.0\n     */\n    checkIfAppUsesLocalMobile(): boolean {\n        return false;\n    }\n\n    /**\n     * Check if local_mobile has been installed in Moodle but the app is not using it.\n     *\n     * @returns Promise resolved it local_mobile was added, rejected otherwise.\n     * @deprecated since app 4.0\n     */\n    async checkIfLocalMobileInstalledAndNotUsed(): Promise<void> {\n        throw new CoreError('Deprecated.');\n    }\n\n    /**\n     * Check if a URL belongs to this site.\n     *\n     * @param url URL to check.\n     * @returns Whether the URL belongs to this site.\n     */\n    containsUrl(url?: string): boolean {\n        if (!url) {\n            return false;\n        }\n\n        const siteUrl = CoreTextUtils.addEndingSlash(CoreUrlUtils.removeProtocolAndWWW(this.siteUrl));\n        url = CoreTextUtils.addEndingSlash(CoreUrlUtils.removeProtocolAndWWW(url));\n\n        return url.indexOf(siteUrl) == 0;\n    }\n\n    /**\n     * Get the public config of this site.\n     *\n     * @param options Options.\n     * @returns Promise resolved with public config. Rejected with an object if error, see CoreWSProvider.callAjax.\n     */\n    async getPublicConfig(options: { readingStrategy?: CoreSitesReadingStrategy } = {}): Promise<CoreSitePublicConfigResponse> {\n        if (!this.db) {\n            if (options.readingStrategy === CoreSitesReadingStrategy.ONLY_CACHE) {\n                throw new CoreError('Cache not available to read public config');\n            }\n\n            return this.requestPublicConfig();\n        }\n\n        const method = 'tool_mobile_get_public_config';\n        const cacheId = this.getCacheId(method, {});\n        const cachePreSets: CoreSiteWSPreSets = {\n            getFromCache: true,\n            saveToCache: true,\n            emergencyCache: true,\n            cacheKey: this.getPublicConfigCacheKey(),\n            ...CoreSites.getReadingStrategyPreSets(options.readingStrategy),\n        };\n\n        if (this.offlineDisabled) {\n            // Offline is disabled, don't use cache.\n            cachePreSets.getFromCache = false;\n            cachePreSets.saveToCache = false;\n            cachePreSets.emergencyCache = false;\n        }\n\n        // Check for an ongoing identical request if we're not ignoring cache.\n\n        // Check for an ongoing identical request.\n        const ongoingRequest = this.getOngoingRequest<CoreSitePublicConfigResponse>(cacheId, cachePreSets);\n        if (ongoingRequest) {\n            return firstValueFrom(ongoingRequest);\n        }\n\n        const subject = new Subject<CoreSitePublicConfigResponse>();\n        const observable = subject.pipe(\n            // Return a clone of the original object, this may prevent errors if in the callback the object is modified.\n            map((data) => CoreUtils.clone(data)),\n            finalize(() => {\n                this.clearOngoingRequest(cacheId, cachePreSets, observable);\n            }),\n        );\n\n        this.setOngoingRequest(cacheId, cachePreSets, observable);\n\n        this.getFromCache<CoreSitePublicConfigResponse>(method, {}, cachePreSets, false)\n            .then(cachedData => cachedData.response)\n            .catch(async () => {\n                if (cachePreSets.forceOffline) {\n                    // Don't call the WS, just fail.\n                    throw new CoreError(Translate.instant('core.cannotconnect'));\n                }\n\n                // Call the WS.\n                try {\n                    const config = await this.requestPublicConfig();\n\n                    if (cachePreSets.saveToCache) {\n                        this.saveToCache(method, {}, config, cachePreSets);\n                    }\n\n                    return config;\n                } catch (error) {\n                    cachePreSets.omitExpires = true;\n                    cachePreSets.getFromCache = true;\n\n                    try {\n                        const cachedData = await this.getFromCache<CoreSitePublicConfigResponse>(method, {}, cachePreSets, true);\n\n                        return cachedData.response;\n                    } catch {\n                        throw error;\n                    }\n                }\n            }).then((response) => {\n                // The app doesn't store exceptions for this call, it's safe to assume type CoreSitePublicConfigResponse.\n                subject.next(<CoreSitePublicConfigResponse> response);\n                subject.complete();\n\n                return;\n            }).catch((error) => {\n                subject.error(error);\n            });\n\n        return firstValueFrom(observable);\n    }\n\n    /**\n     * Get cache key for getPublicConfig WS calls.\n     *\n     * @returns Cache key.\n     */\n    protected getPublicConfigCacheKey(): string {\n        return 'tool_mobile_get_public_config';\n    }\n\n    /**\n     * Perform a request to the server to get the public config of this site.\n     *\n     * @returns Promise resolved with public config.\n     */\n    protected async requestPublicConfig(): Promise<CoreSitePublicConfigResponse> {\n        const preSets: CoreWSAjaxPreSets = {\n            siteUrl: this.siteUrl,\n        };\n\n        let config: CoreSitePublicConfigResponse;\n\n        try {\n            config = await CoreWS.callAjax<CoreSitePublicConfigResponse>('tool_mobile_get_public_config', {}, preSets);\n        } catch (error) {\n            if (!error || error.errorcode !== 'codingerror' || (this.getInfo() && !this.isVersionGreaterEqualThan('3.8'))) {\n                throw error;\n            }\n\n            // This error probably means that there is a redirect in the site. Try to use a GET request.\n            preSets.noLogin = true;\n            preSets.useGet = true;\n\n            try {\n                config = await CoreWS.callAjax<CoreSitePublicConfigResponse>('tool_mobile_get_public_config', {}, preSets);\n            } catch (error2) {\n                if (this.getInfo() && this.isVersionGreaterEqualThan('3.8')) {\n                    // GET is supported, return the second error.\n                    throw error2;\n                } else {\n                    // GET not supported or we don't know if it's supported. Return first error.\n                    throw error;\n                }\n            }\n        }\n\n        // Use the wwwroot returned by the server.\n        if (config.httpswwwroot) {\n            this.siteUrl = CoreUrlUtils.removeUrlParams(config.httpswwwroot); // Make sure the URL doesn't have params.\n        }\n\n        return config;\n    }\n\n    /**\n     * Open a URL in browser using auto-login in the Moodle site if available.\n     *\n     * @param url The URL to open.\n     * @param alertMessage If defined, an alert will be shown before opening the browser.\n     * @param options Other options.\n     * @returns Promise resolved when done, rejected otherwise.\n     */\n    async openInBrowserWithAutoLogin(\n        url: string,\n        alertMessage?: string,\n        options: CoreUtilsOpenInBrowserOptions = {},\n    ): Promise<void> {\n        await this.openWithAutoLogin(false, url, options, alertMessage);\n    }\n\n    /**\n     * Open a URL in browser using auto-login in the Moodle site if available and the URL belongs to the site.\n     *\n     * @param url The URL to open.\n     * @param alertMessage If defined, an alert will be shown before opening the browser.\n     * @param options Other options.\n     * @returns Promise resolved when done, rejected otherwise.\n     * @deprecated since 4.1. Use openInBrowserWithAutoLogin instead, now it always checks that URL belongs to same site.\n     */\n    async openInBrowserWithAutoLoginIfSameSite(\n        url: string,\n        alertMessage?: string,\n        options: CoreUtilsOpenInBrowserOptions = {},\n    ): Promise<void> {\n        return this.openInBrowserWithAutoLogin(url, alertMessage, options);\n    }\n\n    /**\n     * Open a URL in inappbrowser using auto-login in the Moodle site if available.\n     *\n     * @param url The URL to open.\n     * @param options Override default options passed to InAppBrowser.\n     * @param alertMessage If defined, an alert will be shown before opening the inappbrowser.\n     * @returns Promise resolved when done.\n     */\n    async openInAppWithAutoLogin(url: string, options?: InAppBrowserOptions, alertMessage?: string): Promise<InAppBrowserObject> {\n        const iabInstance = <InAppBrowserObject> await this.openWithAutoLogin(true, url, options, alertMessage);\n\n        return iabInstance;\n    }\n\n    /**\n     * Open a URL in inappbrowser using auto-login in the Moodle site if available and the URL belongs to the site.\n     *\n     * @param url The URL to open.\n     * @param options Override default options passed to inappbrowser.\n     * @param alertMessage If defined, an alert will be shown before opening the inappbrowser.\n     * @returns Promise resolved when done.\n     * @deprecated since 4.1. Use openInAppWithAutoLogin instead, now it always checks that URL belongs to same site.\n     */\n    async openInAppWithAutoLoginIfSameSite(\n        url: string,\n        options?: InAppBrowserOptions,\n        alertMessage?: string,\n    ): Promise<InAppBrowserObject> {\n        return this.openInAppWithAutoLogin(url, options, alertMessage);\n    }\n\n    /**\n     * Open a URL in browser or InAppBrowser using auto-login in the Moodle site if available.\n     *\n     * @param inApp True to open it in InAppBrowser, false to open in browser.\n     * @param url The URL to open.\n     * @param options Override default options passed to $cordovaInAppBrowser#open.\n     * @param alertMessage If defined, an alert will be shown before opening the browser/inappbrowser.\n     * @returns Promise resolved when done. Resolve param is returned only if inApp=true.\n     */\n    async openWithAutoLogin(\n        inApp: boolean,\n        url: string,\n        options: InAppBrowserOptions & CoreUtilsOpenInBrowserOptions = {},\n        alertMessage?: string,\n    ): Promise<InAppBrowserObject | void> {\n        // Get the URL to open.\n        const autoLoginUrl = await this.getAutoLoginUrl(url);\n\n        if (alertMessage) {\n            // Show an alert first.\n            const alert = await CoreDomUtils.showAlert(\n                Translate.instant('core.notice'),\n                alertMessage,\n                undefined,\n                3000,\n            );\n\n            await alert.onDidDismiss();\n            options.showBrowserWarning = false; // A warning already shown, no need to show another.\n        }\n\n        options.originalUrl = url;\n\n        // Open the URL.\n        if (inApp) {\n            return CoreUtils.openInApp(autoLoginUrl, options);\n        } else {\n            return CoreUtils.openInBrowser(autoLoginUrl, options);\n        }\n    }\n\n    /**\n     * Open a URL in browser or InAppBrowser using auto-login in the Moodle site if available and the URL belongs to the site.\n     *\n     * @param inApp True to open it in InAppBrowser, false to open in browser.\n     * @param url The URL to open.\n     * @param options Override default options passed to inappbrowser.\n     * @param alertMessage If defined, an alert will be shown before opening the browser/inappbrowser.\n     * @returns Promise resolved when done. Resolve param is returned only if inApp=true.\n     * @deprecated since 4.1. Use openWithAutoLogin instead, now it always checks that URL belongs to same site.\n     */\n    async openWithAutoLoginIfSameSite(\n        inApp: boolean,\n        url: string,\n        options: InAppBrowserOptions & CoreUtilsOpenInBrowserOptions = {},\n        alertMessage?: string,\n    ): Promise<InAppBrowserObject | void> {\n        return this.openWithAutoLogin(inApp, url, options, alertMessage);\n    }\n\n    /**\n     * Get the config of this site.\n     * It is recommended to use getStoredConfig instead since it's faster and doesn't use network.\n     *\n     * @param name Name of the setting to get. If not set or false, all settings will be returned.\n     * @param ignoreCache True if it should ignore cached data.\n     * @returns Promise resolved with site config.\n     */\n    getConfig(name?: undefined, ignoreCache?: boolean): Promise<CoreSiteConfig>;\n    getConfig(name: string, ignoreCache?: boolean): Promise<string>;\n    getConfig(name?: string, ignoreCache?: boolean): Promise<string | CoreSiteConfig> {\n        return firstValueFrom(\n            this.getConfigObservable(<string> name, ignoreCache ? CoreSitesReadingStrategy.ONLY_NETWORK : undefined),\n        );\n    }\n\n    /**\n     * Get the config of this site.\n     * It is recommended to use getStoredConfig instead since it's faster and doesn't use network.\n     *\n     * @param name Name of the setting to get. If not set or false, all settings will be returned.\n     * @param readingStrategy Reading strategy.\n     * @returns Observable returning site config.\n     */\n    getConfigObservable(name?: undefined, readingStrategy?: CoreSitesReadingStrategy): WSObservable<CoreSiteConfig>;\n    getConfigObservable(name: string, readingStrategy?: CoreSitesReadingStrategy): WSObservable<string>;\n    getConfigObservable(name?: string, readingStrategy?: CoreSitesReadingStrategy): WSObservable<string | CoreSiteConfig> {\n        const preSets: CoreSiteWSPreSets = {\n            cacheKey: this.getConfigCacheKey(),\n            ...CoreSites.getReadingStrategyPreSets(readingStrategy),\n        };\n\n        return this.readObservable<CoreSiteConfigResponse>('tool_mobile_get_config', {}, preSets).pipe(map(config => {\n            if (name) {\n                // Return the requested setting.\n                for (const x in config.settings) {\n                    if (config.settings[x].name == name) {\n                        return String(config.settings[x].value);\n                    }\n                }\n\n                throw new CoreError('Site config not found: ' + name);\n            } else {\n                // Return all settings in the same array.\n                const settings: CoreSiteConfig = {};\n                config.settings.forEach((setting) => {\n                    settings[setting.name] = String(setting.value);\n                });\n\n                return settings;\n            }\n        }));\n    }\n\n    /**\n     * Invalidates config WS call.\n     *\n     * @returns Promise resolved when the data is invalidated.\n     */\n    async invalidateConfig(): Promise<void> {\n        await this.invalidateWsCacheForKey(this.getConfigCacheKey());\n    }\n\n    /**\n     * Get cache key for getConfig WS calls.\n     *\n     * @returns Cache key.\n     */\n    protected getConfigCacheKey(): string {\n        return 'tool_mobile_get_config';\n    }\n\n    /**\n     * Get the stored config of this site.\n     *\n     * @param name Name of the setting to get. If not set, all settings will be returned.\n     * @returns Site config or a specific setting.\n     */\n    getStoredConfig(): CoreSiteConfig | undefined;\n    getStoredConfig(name: string): string | undefined;\n    getStoredConfig(name?: string): string | CoreSiteConfig | undefined {\n        if (!this.config) {\n            return;\n        }\n\n        if (name) {\n            return this.config[name];\n        } else {\n            return this.config;\n        }\n    }\n\n    /**\n     * Check if a certain feature is disabled in the site.\n     *\n     * @param name Name of the feature to check.\n     * @returns Whether it's disabled.\n     */\n    isFeatureDisabled(name: string): boolean {\n        const disabledFeatures = this.getStoredConfig('tool_mobile_disabledfeatures');\n        if (!disabledFeatures) {\n            return false;\n        }\n\n        const regEx = new RegExp('(,|^)' + CoreTextUtils.escapeForRegex(name) + '(,|$)', 'g');\n\n        return !!disabledFeatures.match(regEx);\n    }\n\n    /**\n     * Calculate if offline is disabled in the site.\n     */\n    calculateOfflineDisabled(): void {\n        this.offlineDisabled = this.isFeatureDisabled('NoDelegate_CoreOffline');\n    }\n\n    /**\n     * Get whether offline is disabled in the site.\n     *\n     * @returns Whether it's disabled.\n     */\n    isOfflineDisabled(): boolean {\n        return this.offlineDisabled;\n    }\n\n    /**\n     * Check if the site version is greater than one or several versions.\n     * This function accepts a string or an array of strings. If array, the last version must be the highest.\n     *\n     * @param versions Version or list of versions to check.\n     * @returns Whether it's greater or equal, false otherwise.\n     * @description\n     * If a string is supplied (e.g. '3.2.1'), it will check if the site version is greater or equal than this version.\n     *\n     * If an array of versions is supplied, it will check if the site version is greater or equal than the last version,\n     * or if it's higher or equal than any of the other releases supplied but lower than the next major release. The last\n     * version of the array must be the highest version.\n     * For example, if the values supplied are ['3.0.5', '3.2.3', '3.3.1'] the function will return true if the site version\n     * is either:\n     *     - Greater or equal than 3.3.1.\n     *     - Greater or equal than 3.2.3 but lower than 3.3.\n     *     - Greater or equal than 3.0.5 but lower than 3.1.\n     *\n     * This function only accepts versions from 2.4.0 and above. If any of the versions supplied isn't found, it will assume\n     * it's the last released major version.\n     */\n    isVersionGreaterEqualThan(versions: string | string[]): boolean {\n        const info = this.getInfo();\n\n        if (!info || !info.version) {\n            return false;\n        }\n\n        const siteVersion = Number(info.version);\n\n        if (Array.isArray(versions)) {\n            if (!versions.length) {\n                return false;\n            }\n\n            for (let i = 0; i < versions.length; i++) {\n                const versionNumber = this.getVersionNumber(versions[i]);\n                if (i == versions.length - 1) {\n                    // It's the last version, check only if site version is greater than this one.\n                    return siteVersion >= versionNumber;\n                } else {\n                    // Check if site version if bigger than this number but lesser than next major.\n                    if (siteVersion >= versionNumber && siteVersion < this.getNextMajorVersionNumber(versions[i])) {\n                        return true;\n                    }\n                }\n            }\n        } else if (typeof versions == 'string') {\n            // Compare with this version.\n            return siteVersion >= this.getVersionNumber(versions);\n        }\n\n        return false;\n    }\n\n    /**\n     * Given a URL, convert it to a URL that will auto-login if supported.\n     *\n     * @param url The URL to convert.\n     * @param showModal Whether to show a loading modal.\n     * @returns Promise resolved with the converted URL.\n     */\n    async getAutoLoginUrl(url: string, showModal: boolean = true): Promise<string> {\n        if (!this.privateToken) {\n            // No private token, don't change the URL.\n            return url;\n        }\n\n        if (!this.containsUrl(url)) {\n            // URL doesn't belong to the site, don't auto login.\n            return url;\n        }\n\n        if (this.lastAutoLogin > 0) {\n            const timeBetweenRequests = await CoreUtils.ignoreErrors(\n                this.getConfig('tool_mobile_autologinmintimebetweenreq'),\n                CoreConstants.SECONDS_MINUTE * 6,\n            );\n\n            if (CoreTimeUtils.timestamp() - this.lastAutoLogin < timeBetweenRequests) {\n                // Not enough time has passed since last auto login.\n                return url;\n            }\n        }\n\n        const userId = this.getUserId();\n        const params = {\n            privatetoken: this.privateToken,\n        };\n        let modal: CoreIonLoadingElement | undefined;\n\n        if (showModal) {\n            modal = await CoreDomUtils.showModalLoading();\n        }\n\n        try {\n            // Use write to not use cache.\n            const data = await this.write<CoreSiteAutologinKeyResult>('tool_mobile_get_autologin_key', params);\n\n            if (!data.autologinurl || !data.key) {\n                // Not valid data, return the same URL.\n                return url;\n            }\n\n            this.lastAutoLogin = CoreTimeUtils.timestamp();\n\n            return data.autologinurl + '?userid=' + userId + '&key=' + data.key + '&urltogo=' + encodeURIComponent(url);\n        } catch (error) {\n            // Couldn't get autologin key, return the same URL.\n            return url;\n        } finally {\n            modal?.dismiss();\n        }\n    }\n\n    /**\n     * Get a version number from a release version.\n     * If release version is valid but not found in the list of Moodle releases, it will use the last released major version.\n     *\n     * @param version Release version to convert to version number.\n     * @returns Version number, 0 if invalid.\n     */\n    protected getVersionNumber(version: string): number {\n        const data = this.getMajorAndMinor(version);\n\n        if (!data) {\n            // Invalid version.\n            return 0;\n        }\n\n        if (CoreSite.MOODLE_RELEASES[data.major] === undefined) {\n            // Major version not found. Use the last one.\n            const major = Object.keys(CoreSite.MOODLE_RELEASES).pop();\n            if (!major) {\n                return 0;\n            }\n\n            data.major = major;\n        }\n\n        return CoreSite.MOODLE_RELEASES[data.major] + data.minor;\n    }\n\n    /**\n     * Given a release version, return the major and minor versions.\n     *\n     * @param version Release version (e.g. '3.1.0').\n     * @returns Object with major and minor. Returns false if invalid version.\n     */\n    protected getMajorAndMinor(version: string): {major: string; minor: number} | false {\n        const match = version.match(/^(\\d+)(\\.(\\d+)(\\.\\d+)?)?/);\n        if (!match || !match[1]) {\n            // Invalid version.\n            return false;\n        }\n\n        return {\n            major: match[1] + '.' + (match[3] || '0'),\n            minor: parseInt(match[5], 10) || 0,\n        };\n    }\n\n    /**\n     * Given a release version, return the next major version number.\n     *\n     * @param version Release version (e.g. '3.1.0').\n     * @returns Next major version number.\n     */\n    protected getNextMajorVersionNumber(version: string): number {\n        const data = this.getMajorAndMinor(version);\n        const releases = Object.keys(CoreSite.MOODLE_RELEASES);\n\n        if (!data) {\n            // Invalid version.\n            return 0;\n        }\n\n        const position = releases.indexOf(data.major);\n\n        if (position == -1 || position == releases.length - 1) {\n            // Major version not found or it's the last one. Use the last one.\n            return CoreSite.MOODLE_RELEASES[releases[position]];\n        }\n\n        return CoreSite.MOODLE_RELEASES[releases[position + 1]];\n    }\n\n    /**\n     * Deletes a site setting.\n     *\n     * @param name The config name.\n     * @returns Promise resolved when done.\n     */\n    async deleteSiteConfig(name: string): Promise<void> {\n        await this.configTable.deleteByPrimaryKey({ name });\n    }\n\n    /**\n     * Get a site setting on local device.\n     *\n     * @param name The config name.\n     * @param defaultValue Default value to use if the entry is not found.\n     * @returns Resolves upon success along with the config data. Reject on failure.\n     */\n    async getLocalSiteConfig<T extends number | string>(name: string, defaultValue?: T): Promise<T> {\n        try {\n            const entry = await this.configTable.getOneByPrimaryKey({ name });\n\n            return <T> entry.value;\n        } catch (error) {\n            if (defaultValue !== undefined) {\n                return defaultValue;\n            }\n\n            throw error;\n        }\n    }\n\n    /**\n     * Set a site setting on local device.\n     *\n     * @param name The config name.\n     * @param value The config value. Can only store number or strings.\n     * @returns Promise resolved when done.\n     */\n    async setLocalSiteConfig(name: string, value: number | string): Promise<void> {\n        await this.configTable.insert({ name, value });\n    }\n\n    /**\n     * Get a certain cache expiration delay.\n     *\n     * @param updateFrequency The update frequency of the entry.\n     * @returns Expiration delay.\n     */\n    getExpirationDelay(updateFrequency?: number): number {\n        updateFrequency = updateFrequency || CoreSite.FREQUENCY_USUALLY;\n        let expirationDelay = this.UPDATE_FREQUENCIES[updateFrequency] || this.UPDATE_FREQUENCIES[CoreSite.FREQUENCY_USUALLY];\n\n        if (CoreNetwork.isNetworkAccessLimited()) {\n            // Not WiFi, increase the expiration delay a 50% to decrease the data usage in this case.\n            expirationDelay *= 1.5;\n        }\n\n        return expirationDelay;\n    }\n\n    /*\n     * Check if tokenpluginfile script works in the site.\n     *\n     * @param url URL to check.\n     * @returns Promise resolved with boolean: whether it works or not.\n     */\n    checkTokenPluginFile(url: string): Promise<boolean> {\n        if (!CoreUrlUtils.canUseTokenPluginFile(url, this.siteUrl, this.infos && this.infos.userprivateaccesskey)) {\n            // Cannot use tokenpluginfile.\n            return Promise.resolve(false);\n        } else if (this.tokenPluginFileWorks !== undefined) {\n            // Already checked.\n            return Promise.resolve(this.tokenPluginFileWorks);\n        } else if (this.tokenPluginFileWorksPromise) {\n            // Check ongoing, use the same promise.\n            return this.tokenPluginFileWorksPromise;\n        } else if (!CoreNetwork.isOnline()) {\n            // Not online, cannot check it. Assume it's working, but don't save the result.\n            return Promise.resolve(true);\n        }\n\n        url = this.fixPluginfileURL(url);\n\n        this.tokenPluginFileWorksPromise = CoreWS.urlWorks(url).then((result) => {\n            this.tokenPluginFileWorks = result;\n\n            return result;\n        });\n\n        return this.tokenPluginFileWorksPromise;\n    }\n\n    /**\n     * Check if a URL to a file belongs to the site and uses the pluginfileurl or tokenpluginfileurl endpoints.\n     *\n     * @param url File URL to check.\n     * @returns Whether it's a site file URL.\n     */\n    isSitePluginFileUrl(url: string): boolean {\n        const isPluginFileUrl = CoreUrlUtils.isPluginFileUrl(url) || CoreUrlUtils.isTokenPluginFileUrl(url);\n        if (!isPluginFileUrl) {\n            return false;\n        }\n\n        return this.containsUrl(url);\n    }\n\n    /**\n     * Check if a URL to a file belongs to the site and is a theme image file.\n     *\n     * @param url File URL to check.\n     * @returns Whether it's a site theme image URL.\n     */\n    isSiteThemeImageUrl(url: string): boolean {\n        if (!CoreUrlUtils.isThemeImageUrl(url)) {\n            return false;\n        }\n\n        return this.containsUrl(url);\n    }\n\n    /**\n     * Deletes last viewed records based on some conditions.\n     *\n     * @param conditions Conditions.\n     * @returns Promise resolved when done.\n     */\n    async deleteLastViewed(conditions?: Partial<CoreSiteLastViewedDBRecord>): Promise<void> {\n        await this.lastViewedTable.delete(conditions);\n    }\n\n    /**\n     * Get a last viewed record for a component+id.\n     *\n     * @param component The component.\n     * @param id ID.\n     * @returns Resolves with last viewed record, undefined if not found.\n     */\n    async getLastViewed(component: string, id: number): Promise<CoreSiteLastViewedDBRecord | undefined> {\n        try {\n            return await this.lastViewedTable.getOneByPrimaryKey({ component, id });\n        } catch {\n            // Not found.\n        }\n    }\n\n    /**\n     * Get several last viewed for a certain component.\n     *\n     * @param component The component.\n     * @param ids IDs. If not provided or empty, return all last viewed for a component.\n     * @returns Resolves with last viewed records, undefined if error.\n     */\n    async getComponentLastViewed(component: string, ids: number[] = []): Promise<CoreSiteLastViewedDBRecord[] | undefined> {\n        try {\n            if (!ids.length) {\n                return await this.lastViewedTable.getMany({ component });\n            }\n\n            const whereAndParams = SQLiteDB.getInOrEqual(ids);\n\n            whereAndParams.sql = 'id ' + whereAndParams.sql + ' AND component = ?';\n            whereAndParams.params.push(component);\n\n            return await this.lastViewedTable.getManyWhere({\n                sql: whereAndParams.sql,\n                sqlParams: whereAndParams.params,\n                js: (record) => record.component === component && ids.includes(record.id),\n            });\n        } catch {\n            // Not found.\n        }\n    }\n\n    /**\n     * Store a last viewed record.\n     *\n     * @param component The component.\n     * @param id ID.\n     * @param value Last viewed item value.\n     * @param options Options.\n     * @returns Promise resolved when done.\n     */\n    async storeLastViewed(\n        component: string,\n        id: number,\n        value: string | number,\n        options: CoreSiteStoreLastViewedOptions = {},\n    ): Promise<void> {\n        await this.lastViewedTable.insert({\n            component,\n            id,\n            value: String(value),\n            data: options.data,\n            timeaccess: options.timeaccess ?? Date.now(),\n        });\n    }\n\n}\n\n/**\n * Operator to chain requests when using observables.\n *\n * @param readingStrategy Reading strategy used for the current request.\n * @param callback Callback called with the result of current request and the reading strategy to use in next requests.\n * @returns Operator.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function chainRequests<T, O extends ObservableInput<any>>(\n    readingStrategy: CoreSitesReadingStrategy | undefined,\n    callback: (data: T, readingStrategy?: CoreSitesReadingStrategy) => O,\n): OperatorFunction<T, ObservedValueOf<O>> {\n    return (source: WSObservable<T>) => new Observable<{ data: T; readingStrategy?: CoreSitesReadingStrategy }>(subscriber => {\n        let firstValue = true;\n        let isCompleted = false;\n\n        return source.subscribe({\n            next: async (value) => {\n                if (readingStrategy !== CoreSitesReadingStrategy.STALE_WHILE_REVALIDATE) {\n                    // Just use same strategy.\n                    subscriber.next({ data: value, readingStrategy });\n\n                    return;\n                }\n\n                if (!firstValue) {\n                    // Second (last) value. Chained requests should have used cached data already, just return 1 value now.\n                    subscriber.next({\n                        data: value,\n                    });\n\n                    return;\n                }\n\n                firstValue = false;\n\n                // Wait to see if the observable is completed (no more values).\n                await CoreUtils.nextTick();\n\n                if (isCompleted) {\n                    // Current request only returns cached data. Let chained requests update in background.\n                    subscriber.next({ data: value, readingStrategy });\n                } else {\n                    // Current request will update in background. Prefer cached data in the chained requests.\n                    subscriber.next({\n                        data: value,\n                        readingStrategy: CoreSitesReadingStrategy.PREFER_CACHE,\n                    });\n                }\n            },\n            error: (error) => subscriber.error(error),\n            complete: async () => {\n                isCompleted = true;\n\n                await CoreUtils.nextTick();\n\n                subscriber.complete();\n            },\n        });\n    }).pipe(\n        mergeMap(({ data, readingStrategy }) => callback(data, readingStrategy)),\n    );\n}\n\n/**\n * PreSets accepted by the WS call.\n */\nexport type CoreSiteWSPreSets = {\n    /**\n     * Get the value from the cache if it's still valid.\n     */\n    getFromCache?: boolean;\n\n    /**\n     * Save the result to the cache.\n     */\n    saveToCache?: boolean;\n\n    /**\n     * Ignore cache expiration.\n     */\n    omitExpires?: boolean;\n\n    /**\n     * Use the cache when a request fails. Defaults to true.\n     */\n    emergencyCache?: boolean;\n\n    /**\n     * If true, the app won't call the WS. If the data isn't cached, the call will fail.\n     */\n    forceOffline?: boolean;\n\n    /**\n     * Extra key to add to the cache when storing this call, to identify the entry.\n     */\n    cacheKey?: string;\n\n    /**\n     * Whether it should use cache key to retrieve the cached data instead of the request params.\n     */\n    getCacheUsingCacheKey?: boolean;\n\n    /**\n     * Same as getCacheUsingCacheKey, but for emergency cache.\n     */\n    getEmergencyCacheUsingCacheKey?: boolean;\n\n    /**\n     * If true, the cache entry will be deleted if the WS call returns an exception.\n     */\n    deleteCacheIfWSError?: boolean;\n\n    /**\n     * Whether it should only be 1 entry for this cache key (all entries with same key will be deleted).\n     */\n    uniqueCacheKey?: boolean;\n\n    /**\n     * Whether to filter WS response (moodlewssettingfilter). Defaults to true.\n     */\n    filter?: boolean;\n\n    /**\n     * Whether to rewrite URLs (moodlewssettingfileurl). Defaults to true.\n     */\n    rewriteurls?: boolean;\n\n    /**\n     * Language to send to the WebService (moodlewssettinglang). Defaults to app's language.\n     */\n    lang?: string;\n\n    /**\n     * Defaults to true. Set to false when the expected response is null.\n     */\n    responseExpected?: boolean;\n\n    /**\n     * Defaults to 'object'. Use it when you expect a type that's not an object|array.\n     */\n    typeExpected?: CoreWSTypeExpected;\n\n    /**\n     * Wehther a pending request in the queue matching the same function and arguments can be reused instead of adding\n     * a new request to the queue. Defaults to true for read requests.\n     */\n    reusePending?: boolean;\n\n    /**\n     * Whether the request will be be sent immediately as a single request. Defaults to false.\n     */\n    skipQueue?: boolean;\n\n    /**\n     * Cache the response if it returns an errorcode present in this list.\n     */\n    cacheErrors?: string[];\n\n    /**\n     * Update frequency. This value determines how often the cached data will be updated. Possible values:\n     * CoreSite.FREQUENCY_USUALLY, CoreSite.FREQUENCY_OFTEN, CoreSite.FREQUENCY_SOMETIMES, CoreSite.FREQUENCY_RARELY.\n     * Defaults to CoreSite.FREQUENCY_USUALLY.\n     */\n    updateFrequency?: number;\n\n    /**\n     * Component name. Optionally included if this request is being made on behalf of a specific\n     * component (e.g. activity).\n     */\n    component?: string;\n\n    /**\n     * Component id. Optionally included when 'component' is set.\n     */\n    componentId?: number;\n\n    /**\n     * Whether to split a request if it has too many parameters. Sending too many parameters to the site\n     * can cause the request to fail (see PHP's max_input_vars).\n     */\n    splitRequest?: CoreWSPreSetsSplitRequest;\n\n    /**\n     * If true, the app will return cached data even if it's expired and then it'll call the WS in the background.\n     * Only enabled if CoreConstants.CONFIG.disableCallWSInBackground isn't true.\n     */\n    updateInBackground?: boolean;\n};\n\n/**\n * Response of checking local_mobile status.\n *\n * @deprecated since app 4.0\n */\nexport type LocalMobileResponse = {\n    /**\n     * Code to identify the authentication method to use.\n     */\n    code: number;\n\n    /**\n     * Name of the service to use.\n     */\n    service?: string;\n\n    /**\n     * Code of the warning message.\n     */\n    warning?: string;\n\n    /**\n     * Whether core SSO is supported.\n     */\n    coreSupported?: boolean;\n};\n\n/**\n * Info of a request waiting in the queue.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RequestQueueItem<T = any> = {\n    cacheId: string;\n    method: string;\n    data: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n    preSets: CoreSiteWSPreSets;\n    wsPreSets: CoreWSPreSets;\n    deferred: CorePromisedValue<T>;\n};\n\n/**\n * Result of WS core_webservice_get_site_info.\n */\nexport type CoreSiteInfoResponse = {\n    sitename: string; // Site name.\n    username: string; // Username.\n    firstname: string; // First name.\n    lastname: string; // Last name.\n    fullname: string; // User full name.\n    lang: string; // Current language.\n    userid: number; // User id.\n    siteurl: string; // Site url.\n    userpictureurl: string; // The user profile picture.\n    functions: {\n        name: string; // Function name.\n        version: string; // The version number of the component to which the function belongs.\n    }[];\n    downloadfiles?: number; // 1 if users are allowed to download files, 0 if not.\n    uploadfiles?: number; // 1 if users are allowed to upload files, 0 if not.\n    release?: string; // Moodle release number.\n    version?: string; // Moodle version number.\n    mobilecssurl?: string; // Mobile custom CSS theme.\n    advancedfeatures?: { // Advanced features availability.\n        name: string; // Feature name.\n        value: number; // Feature value. Usually 1 means enabled.\n    }[];\n    usercanmanageownfiles?: boolean; // True if the user can manage his own files.\n    userquota?: number; // User quota (bytes). 0 means user can ignore the quota.\n    usermaxuploadfilesize?: number; // User max upload file size (bytes). -1 means the user can ignore the upload file size.\n    userhomepage?: CoreSiteInfoUserHomepage; // The default home page for the user.\n    userprivateaccesskey?: string; // Private user access key for fetching files.\n    siteid?: number; // Site course ID.\n    sitecalendartype?: string; // Calendar type set in the site.\n    usercalendartype?: string; // Calendar typed used by the user.\n    userissiteadmin?: boolean; // Whether the user is a site admin or not.\n    theme?: string; // Current theme for the user.\n};\n\n/**\n * Site info, including some calculated data.\n */\nexport type CoreSiteInfo = CoreSiteInfoResponse & {\n    functionsByName?: {\n        [name: string]: {\n            name: string; // Function name.\n            version: string; // The version number of the component to which the function belongs.\n        };\n    };\n};\n\n/**\n * Enum constants that define default user home page.\n */\nexport enum CoreSiteInfoUserHomepage {\n    HOMEPAGE_SITE = 0, // Site home.\n    HOMEPAGE_MY = 1, // Dashboard.\n    HOMEPAGE_MYCOURSES = 3, // My courses.\n}\n\n/**\n * Result of WS tool_mobile_get_config.\n */\nexport type CoreSiteConfigResponse = {\n    settings: { // Settings.\n        name: string; // The name of the setting.\n        value: string | number; // The value of the setting.\n    }[];\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Possible values for 'supportavailability' config.\n */\nexport const enum CoreSiteConfigSupportAvailability {\n    Disabled = 0,\n    Authenticated = 1,\n    Anyone = 2,\n}\n\n/**\n * Site config indexed by name.\n */\nexport type CoreSiteConfig = Record<string, string> & {\n    supportavailability?: string; // String representation of CoreSiteConfigSupportAvailability.\n};\n\n/**\n * Result of WS tool_mobile_get_public_config.\n */\nexport type CoreSitePublicConfigResponse = {\n    wwwroot: string; // Site URL.\n    httpswwwroot: string; // Site https URL (if httpslogin is enabled).\n    sitename: string; // Site name.\n    guestlogin: number; // Whether guest login is enabled.\n    rememberusername: number; // Values: 0 for No, 1 for Yes, 2 for optional.\n    authloginviaemail: number; // Whether log in via email is enabled.\n    registerauth: string; // Authentication method for user registration.\n    forgottenpasswordurl: string; // Forgotten password URL.\n    authinstructions: string; // Authentication instructions.\n    authnoneenabled: number; // Whether auth none is enabled.\n    enablewebservices: number; // Whether Web Services are enabled.\n    enablemobilewebservice: number; // Whether the Mobile service is enabled.\n    maintenanceenabled: number; // Whether site maintenance is enabled.\n    maintenancemessage: string; // Maintenance message.\n    logourl?: string; // The site logo URL.\n    compactlogourl?: string; // The site compact logo URL.\n    typeoflogin: number; // The type of login. 1 for app, 2 for browser, 3 for embedded.\n    launchurl?: string; // SSO login launch URL.\n    mobilecssurl?: string; // Mobile custom CSS theme.\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    tool_mobile_disabledfeatures?: string; // Disabled features in the app.\n    identityproviders?: CoreSiteIdentityProvider[]; // Identity providers.\n    country?: string; // Default site country.\n    agedigitalconsentverification?: boolean; // Whether age digital consent verification is enabled.\n    supportname?: string; // Site support contact name (only if age verification is enabled).\n    supportemail?: string; // Site support contact email (only if age verification is enabled).\n    supportavailability?: CoreSiteConfigSupportAvailability;\n    supportpage?: string; // Site support contact url.\n    autolang?: number; // Whether to detect default language from browser setting.\n    lang?: string; // Default language for the site.\n    langmenu?: number; // Whether the language menu should be displayed.\n    langlist?: string; // Languages on language menu.\n    locale?: string; // Sitewide locale.\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    tool_mobile_minimumversion?: string; // Minimum required version to access.\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    tool_mobile_iosappid?: string; // IOS app's unique identifier.\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    tool_mobile_androidappid?: string; // Android app's unique identifier.\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    tool_mobile_setuplink?: string; // App download page.\n    tool_mobile_qrcodetype?: CoreSiteQRCodeType; // eslint-disable-line @typescript-eslint/naming-convention\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Identity provider.\n */\nexport type CoreSiteIdentityProvider = {\n    name: string; // The identity provider name.\n    iconurl: string; // The icon URL for the provider.\n    url: string; // The URL of the provider.\n};\n\n/**\n * Result of WS tool_mobile_get_autologin_key.\n */\nexport type CoreSiteAutologinKeyResult = {\n    key: string; // Auto-login key for a single usage with time expiration.\n    autologinurl: string; // Auto-login URL.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Result of WS tool_mobile_call_external_functions.\n */\nexport type CoreSiteCallExternalFunctionsResult = {\n    responses: {\n        error: boolean; // Whether an exception was thrown.\n        data?: string; // JSON-encoded response data.\n        exception?: string; // JSON-encoed exception info.\n    }[];\n};\n\n/**\n * Options for storeLastViewed.\n */\nexport type CoreSiteStoreLastViewedOptions = {\n    data?: string; // Other data.\n    timeaccess?: number; // Accessed time. If not set, current time.\n};\n\n/**\n * Info about cached data.\n */\ntype WSCachedData<T> = {\n    response: T | WSCachedError; // The WS response data, or an error if the WS returned an error and it was cached.\n    expirationIgnored: boolean; // Whether the expiration time was ignored.\n    expirationTime?: number; // Entry expiration time (only if not ignored).\n};\n\n/**\n * Error data stored in cache.\n */\ntype WSCachedError = {\n    exception?: string;\n    errorcode?: string;\n};\n\n/**\n * Observable returned when calling WebServices.\n * If the request uses the \"update in background\" feature, it will return 2 values: first the cached one, and then the one\n * coming from the server. After this, it will complete.\n * Otherwise, it will only return 1 value, either coming from cache or from the server. After this, it will complete.\n */\nexport type WSObservable<T> = Observable<T>;\n\n/**\n * Type of ongoing requests stored in memory to avoid duplicating them.\n */\nenum OngoingRequestType {\n    STANDARD = 0,\n    UPDATE_IN_BACKGROUND = 1,\n}\n"
        }
    ]
}